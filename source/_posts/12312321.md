---
title: C#学习
date: 2023-07-23
password: mysecretpassword
encrypt: false
---

# chap_01 C#历史

为了对标JAVA,完全是模仿的JAVA;

JAVA是Oracle,.Net是开源;二者是双胞胎;但是有些不一样;

## C#的CLI和CLR

- CLI:处理代码编译过程--->生成一个中间公共语言的程序
- CLR:服务环境---->相当于JAVA的JVM

为了跨平台,出现了虚拟机,比如C#,他放弃了直接编译机器语言;

编程成了IL(Intermediate Language),类似于汇编,有可读性;但是必须现在系统安装.NET Core,他来解释IL,但是他是**JIT（即时编译）**,这样Win Linux 就会跨平台了;

![image-20230309162842929](./assets/image-20230309163603623-1681195526166-1.png)

过程就是如上述;而这个IL,MS可以兼容C++ VB F#;但是目前没用过;

C#使用的编译器是CSC,然后最后打包(Windows)变成exe文件,这个是可以用spy反汇编的,这样是C#的一大特点;

在Windows平台下的EXE你可以理解为里面有IL,也就是中间公共语言,还有能打开Core的代码,而这个能打开Core的代码肯定是不同架构不一样,这就是为什么C#需要对不同平台进行打包,如果Win上面,就打包成exe;但是主要的IL是不变的;

通过IL Dsm可以查看这个IL公共语言

![image-20230309163603623](E:\notes\Notes\C#\assets\image-20230309163603623-1681195526166-1.png)



有一定可读性,但是他必须运行在CLR中;C#所有语言都必须在CLR中运行;

![image-20230309163654219](.\assets\image-20230309163654219-1681195526167-3.png)

 



## MS的.NET产品线的历程

微软名字起的很垃圾;一会Framework,一会叫.NET core

![image-20230309164022240](E:\notes\Notes\C#\assets\image-20230309164022240-1681195526168-4.png)

.NET Framework 4.8是最后一个绝唱了;

![image-20230309164047332](E:\notes\Notes\C#\assets\image-20230309164047332-1681195526168-5.png)

==所以.NET Framework是已经废了==;.NET 5==.NET Core;这是因为MS的.NET产品线太混乱了;

# chap_02 Hello World项目刨析

using System;是C#的最基本的模块

比如标准输出,就来源于System这个模块;

而System这种模块,叫做命名空间;

而我们的hello world这个程序,实际上也是在一个命名空间的,别人直接using 就可以使用我们这个函数了;

![image-20230309165548438](E:\notes\Notes\C#\assets\image-20230309165548438-1681195536143-12.png)

![image-20230309165858451](E:\notes\Notes\C#\assets\image-20230309165858451-1681195536143-11.png)



## System.Console

 在Console中,通常有以下函数

- **Write**

  STD OUT,

- **WriteLine**

​	这个会光标是下一行,相当于是会换行;这就是和Console.Write()的区别;

- **Read**

​	他会读取第一个键盘按下的ASCII代码;

- **ReadKey**

​	这个可以读取回车,和Read类似,但是返回值是ConsoleKeyInfo;

- **ReadLine**

​	这个可以回车之前的所有数据;

- **Clear**

​	一敲击键盘,所有输入输出都消失了;

## C#的变量

总体上和c/cpp一样,但是所有的类型都相当于是个类,都有很多成员函数

C#一共有13种定义好的基本类型

![image-20230309171641698](E:\notes\Notes\C#\assets\image-20230309171641698-1681195536143-13.png)

- 整数 int
- 浮点数 float
- 布尔 bool

- String(和Cpp封装的哪个类似)
- double
- char

C#和java和C++一样,还是需要定义类型的;也算一种强类型的变成语言；

需要注意的是,long就有点像c++的long long,还有char 是两个字节,其他都是和C++很像了;

还有属于内建类型,但是不属于基本类型,比如string,object,dynamic;

## string类型的操作

C#有string和大写String,这两是有区别的;

事实上小写string就是大写String的别名,是完全一样;

### 字符串拼接

```c#
    string hello = "hello world\r\n";
    string hello1 = "aloha world";
    string merge = hello + hello1;
```

### 字符串格式化操作

有三种,一种是{X},还有一种是format函数,第三章就是前面加$符号

```c#
            //字符串格式化操作
            string name = "lee jack",age="21";
            Console.WriteLine("My name {0}.My years old is{1}",name, age);

            //string.format格式化
            string format_string = "My name is{0}.";
            string format=string.Format(format_string, name);

            //另一种 这种更方便 这个叫做字符串内嵌
            string format_2 = $"My name is {name}";
```

### 字符串换行

可以用原意字符串,前面加@,也可以用\r\n

```c#
            //字符串换行 可以\r\n 
            //当然,如果想显示\r\n这种转义字符,也可以用原意字符串 这个时候换行			用"物理换行"
            string new_line = @"hhahah\r\n
            DAADAD\r\n
            adasfad";
```

### 字符串函数操作

这个需要自己去探索,C#肯定是封装了很多有用的函数的;比C++的string要多;

## C#的方法(函数)

其实就是C++的函数,但是声明比较麻烦.

方法签名---->就是C/CPP的函数声明

**值得一提的是,所有的方法必须放在类里面;**

![image-20230309184145736](E:\notes\Notes\C#\assets\image-20230309184145736-1681195536147-14.png)

首先Access Specifier叫做访问修饰符

![image-20230309184704016](E:\notes\Notes\C#\assets\image-20230309184704016-1681195536148-16.png)

第二个是Modify,声明修饰符

 ![image-20230309184924735](E:\notes\Notes\C#\assets\image-20230309184924735-1681195536148-17.png)

![image-20230309185025716](E:\notes\Notes\C#\assets\image-20230309185025716-1681195536148-15.png)

 其他的和C++完全一样,一个访问修饰符,一个声明修饰符不太一样;

# chap_03 C#的面向对象

C#的面向对象也就是OOP是在面向过程编程发展起来的；

面向对象可以描述世界中一切事物;而代码运行的结果就是各个对象相互作用的结果;

而在C#中一切都是对象,一切一切....

## 对象与类

类和对象是息息相关的,也就是表示对象的总和;

而类实例化(可以理解初始化)之后就变成了类;

和C++一样,可以使用new 来实例化一个类

### 类、实例、对象的关系

![image-20230312172540218](E:\notes\Notes\C#\assets\image-20230312172540218-1681195926496-25.png)

所以面向对象核心就是如何定义类,而定义类就是class 类名{}

## static非static的成员函数

这一点和C++很像,非static就是有this,C#中也可以用this,只不过是C++中是指针,而C#直接用.运算即可;

一旦加了static这个修饰符,也就代表只能操作static对象,也就是说假如此时定义一个类实例对象,

改对象这个static函数无法使用,只要类.实例函数才能使用;

```C#
public static double GetDistance(Point p1, Point p2)
            {//这个代表一句话返回
                double d = Math.Pow(p1.x - p2.x, 2) + Math.Pow(p1.y - p2.y, 2);
                return Math.Pow(d, 0.5);
            
            }
```

如上图,只能用

`Point.GetInstance()`而不是`p.GetInstance()`这样使用;值得一提的是，C#中类中任何任何成员,函数都必须具备==访问修饰符,即private,public等==,一行一个;

## C#的Ctor

和C++类似,C#也有构造函数,也支持重载;

```c#
            public Point() { x = 0;y = 0; }
            public Point(int x,int y) { this.x = x;this.y = y; }
```

这样就是ctor;

而C#的Ctor初始化有些不同,这是因为,C#的所有对象都是new出来的,也无需考虑delete等问题;

假如要new数组,就直接string[] words=new string[];==一切都是动态的,不需要释放,不需要考虑数组大小问题==

想要new一个类,就直接class obj=new class();而这个()里面就可以使用构造函数的参数了;

```C
Point p1 = new Point(0,0);
```

## set、get(自动属性)

可谓是C#让我最眼前一新的功能了;

这个功能可以用于那些private但是又必须获取的成员变量,比如

```C#
class Point{
    
    public int X{get;set;}
    private int x;
    private int y;
}

```

其中的`public int X{get;set;}`就是默认的get、set函数,这就相当于是有三个成员,而大X可以直接用于直接进行赋值;

但是这看起来似乎又没什么用,但是他又另一个用处,就是可以自定义X这个函数的set、get;

比如这样

```C#
public class Point{
    
    public int X{
        get{
         return this.x;   
        }
        set{
            this.x=value;
        }
    }
    private int x;
}

```

这样可以把X和x关联起来,这样使用大X其实就是使用小x,而value是C#自带的属于set里面的关键字;

事实上,在C#的实际使用中,基本上这个属性都是`public`;

## readonly和const

其实就是Access限定符不一样,而readonly和const的区别就是readonly代表每个类实例后的对象不一样,但是const都开始就确定了,而readonly一般是在==构造函数中初始化的,此后再也不能修改==;

## 关于索引

### 类中重载索引

C#的索引灵活多变,首先,它可以在类中重载索引,重载如下,有点像C++的重载索引运算符

```c#
            public string this[int index]
            {
                get
                {
                    return words[index];
                }
                set
                {
                    words[index] = value;

                }
            }
```

```C#
 public static Over operator + (Over o1,Over o2)
            {


                return new Over(o1.x + o2.x);
            }
```

只不过有些重载,必须要加public和static;比如+ -

而且重载下标和`cpp`也不太一样;

### 其他的索引运用

总之和C差不多,new出来一个[]之后,0开始,但是C#配备了倒数第几个,^1代表倒数第一个,以此类推;

当然,C#还有一个Range,用0..3表示,如下

```C#
var list = words[0..3];
```

需要注意的是,这里的var就相当于是C++的==auto==,等价于==string[] list=words[0..3]==;这里需要特别注意,C#的数组和C++/C区别就是C#数组在类型后,而C++在名称后;



## partial类

partial就是可以把一个类拆开写,如下

```C#
public partial class Point{
    
    private int x;
    
}

public partial class Point{
    
    private int y;
}
```

等价于

```c#
public partial class Point{
    
    private int x;
    private int y;
    
}
```

这样做的好处是可以把class Point分为不同的cs文件,这样用来分开文件可以更明确;不同功能但是同一个类可以分开文件写;

>  ==总的来说,C#一切皆对象,整个程序都可以抽象成一个对象,对于C#来说,函数签名的修饰符非常非常重要==
>
> 其次,C#类中有类,自带"头文件",把类写入namespace,引入的时候只需要using namespace;即可
>
> 类中也可以有类,使用方法就是class0.class1;当然,需要**先using namespace**

# chap04 继承和复合

## 类耦合

通常,`高内聚,低耦合`是判断代码好坏的关键;

耦合就是各种类和子系统的依存关系,如下图;

![image-20230411150013461](E:\notes\Notes\C#\assets\image-20230411150013461.png)

比如,在代码中修改了class A,引起雪崩效应,这就是高耦合代码;

实际工作中,尽量不要使用,尽量使用低耦合;

即存在`从属关系`,不是`依存关系`

### 低耦合办法

- 封装

比如对于业务逻辑实现细节隐藏

- 类的关联性

- 使用接口

是面向对象的核心;

## 继承

==两个类之间的关系==;

继承的好处都有

- **省去重复性基础代码**
- **产生多态**

> 即继承对象的同一个行为产生不同的表现;

比如下图继承的关系

![image-20230411150710110](E:\notes\Notes\C#\assets\image-20230411150710110.png)

### 继承语法的结构

```c#
namespace 类继承
{
    public class PresentationObject
    {
        public int Width { get; set; }
        public int Height { get; set; }
        
       
    }

}  
class Text : PresentationObject
        {
            public int FontSize { set; get; }

        }

```

在继承完之后,使用这个Text类实例化对象后,会发现,除了本身自己的方法，还有基类的方法,还有一些重未定义的方法;这是因为C#中所有的类都继承一个基类`Object`;这里面预先实现了最基本的方法;

## 复合

> 复合同样是两个类之间的关系
>
> 复合是有一个==的关系==

好处:

- 代码复用
- 依赖注入,适合大型项目开发;

比如,一个数据迁移系统有Logger和Installer和本体；

画图可以画成

![image-20230411152155637](E:\notes\Notes\C#\assets\image-20230411152155637.png)

Has-a,这就是复合直接的关系;

==即对象中有对象==

这里需要注意和前面的类中有类的关系的区别;(事实上这个耦合度比较高,依赖注入和IOC才能使耦合度降低);

## protected与internal

在C#中,一般有5个修饰符

**public(任何都能访问这个类)** **private(除了类本身)** **protected(子类)** internal 以及 protected internal

### protected

只要修饰符是这个,那么只有本身和子类才能访问;

### internal

使用范围被限定在当前项目,即我引用其他项目,这个也不能用;

就正如C#的==类库==,然后在项目中添加-项目引用；

不是同一个项目,如果internal修饰符,那么就不能在别的用了;

## 构造方法的继承

构造函数的执行是

Base.ctor->Son.ctor;

而如果基类有多个构造函数,一般是==调用无参默认构造函数==;

如果需要指定某个基类的特定的构造函数;

如下述代码

```C#
      public class Staff
        {
            public Staff()
            {

                Console.Write($"staff\r\n");

            }

            public int Number { get; set; }
        
            public Staff(int number)
            {
                Number = number;
            }

        }

        public class Boss : Staff { 
        
            public Boss()
            {

                Console.Write($"Boss\r\n");
            }
            
            public Boss(int number)
            {
                Console.WriteLine($"num={this.Number}");
                //this.Number = number;
            }
        }


```

如果调用Boss的有参构造,事实上Number还是0,因为会执行默认的Base构造函数;

这个时候需要指定,使用`Base指定`;

```c#
public Boss(int number):base(number)
            {
                Console.WriteLine($"num={this.Number}");
                //this.Number = number;
            }
```

通过Base关键词即可选择正确选择的构造函数

## 向上向下转型

### 向上转型

> 把派生类到基类的转换

### 向下转型

> 把基类到派生类的转换

在C#和CPP中,向上转型都十分随意,可以随便转;

但是如果向下转型,有可能会失败;

```C#
Car car=(Car)obj
```

这样如果转失败,对于C#可能会出异常,这里推荐C#的类型转换

```C#
Car car=obj as Car;
if(car==null){
    
    //失败操作
}
```

会把car这个指针悬空;

还可以

```c#
if(obj is Car){
    //是操作
    
}
```

事实上,C#的向上转换本质上就是指针的切换,他们没有切换内存;

指向的都是同一块地方;

## 动态类型列表

C#中列表就是数组;其中有个动态类型的链表,叫做ArraryList;

在使用ArraryList之前需要先`using System.Collections;`

事实上,ArrayList的原理就是用了`向上转型`,因为从派生->基类是可以转的;

而C#任何对象有是基于Object的,因此array.Add()就可以添加任何对象;

同样,也可以用==泛型(类似CPP的模板)==的List来进行

```c#
var shape_list=new List<Shape>();
```

## 对象的装箱和拆箱

在C#的中没有指针,分为指和引用;

指引用都放在栈中,而引用实际上原理就是指针;

- 装箱

就是值类型转换成引用类型,即栈的值->heap

比如`var t=new int(5);`就是5到heap的转换;

或者是`int a=5; var t=new object(a)`;

- 拆箱

即当对象类型转换成值类型

这里需要注意,所谓的值类型的引用类型;

并不是说`var t=object(5)`,这t虽然存在stack中(按照cpp理解),但是并不是值类型,他是类,所有是引用类型;

值类型是值那些只有值的类型,比如`int bool 结构体等`;

### 泛型的FOR循环

C#中支持泛型,可以用

`var t = new List<object>`来进行生成一个链表;

这个时候可以用`t.add()`来进行添加

而进行的for循环也会改变,只需要

`foreach(var xx in t)`即可遍历t中链表的每个元素;

类似于cpp的`for(:)`来完成;

# chap05 多态

## 多态的使用

即重写基类原来的方法;

但是前面必须加上`virtual`来进行设置;

然后,在派生类重写,需要加上`override`这个关键词;

而C#可以自动识别当前类型;本质上是因为指针指向的是同一块地方;

也就是说,哪怕你把派生类向上转换成基类,那么你使用基类的的`方法`,如果存在多态,那么最终调用的方法事实上是`派生类的`;

这一点和cpp也是类似;

## 抽象类

即使用abstract来定义不可以实例化的类;只定义`接口`,而使用类;

- 类的方法或者成员一旦abstract,类也必须定义抽象;

- 派生类必须实现抽象类的所有的方法;

## 密封类和密封成员

他和抽象修饰符`abstract`,他和抽象修饰符是完全相反的;

如果类用了,`sealed`这个类就不可以被继承;

如果类的成员用了`sealed`,那么这个成员函数则不可以被重写;

# chap06 接口

## 接口的声明

声明接口和声明类很相似;

```C#
public interface ICalculator{
    
    int Calculate();
}
```

业界规定,声明的接口必须前面加上`I`来代表接口;

而且没有访问修饰符,所有接口内的方法都是public;

接口可以满足`低耦合的目的`;

比如原来的`Has-a`的关系,对象中有对象,完全可以用接口来进行;

==我的理解,接口可以理解为类继承了一个虚函数,必须实现,别人可以使用这个接口来根据多态使用这个函数 后面通过依赖注入可以改变class`Has-a`的关系==

## 接口使用

在类用使用接口,类似于继承,需要

```C#
//定义接口
interface IShippingCalculator
    {
        float CalculateShipping(Order order);
    }
//不同的类使用同一个接口
   class DoubleElevenShippingCalculator : IShippingCalculator
    {
        public float CalculateShipping(Order order)
        {
            return 0f;
        }
    }
class ShippingCalculator : IShippingCalculator
    {
        public float CalculateShipping(Order order)
        {
            if (order.TotalPrice >= 50f)
            {
                return 0;
            }
            return 10f;
        }
    }
```

这样,一个接口就可以有两个类了,然后在如下new 两个接口

```C#
// 双十一
            IShippingCalculator doubleEleven = new DoubleElevenShippingCalculator();
            // 普通
            IShippingCalculator putong = new ShippingCalculator();
```

这个时候一定不要再用`var`关键字了;

然后核心逻辑类中需要有个`has-a`关系的接口

```C#
class OrderProcessor
    {
        private readonly IShippingCalculator _shippingCalculator;
}
```

这样,只需要在自己类中判断核心逻辑,然后决定用哪一个接口就好了;

```C#
if (DateTime.Now == new DateTime(2050, 11, 11))
            {
                orderProcessor = new OrderProcessor(doubleEleven);
            }
            else
            {
                orderProcessor = new OrderProcessor(putong);
            }
```

这便是接口的核心以及使用方法了，本质上还是需要创建两个类;

可以理解为把拥有类换成了拥有接口,然后new Obj,这个Obj是继承接口的很多个,==本质上有点类似多态,使用了向上转换==;

但是这种依赖关系会变弱,==紧紧依赖于接口==,有点像CPP的`delegatation`,也就是委托,只不过cpp有指针的概念,所以存的是指针,可以完成多态;

## 反转控制与依赖注入

这是一种软件涉及模式;

这是属于C#的重点的重点,也是很难的;

>  IOC指的是将控制权从代码中转移出来，使得代码不再掌控对象的创建和管理，而是将这些任务交给外部容器（如Spring、Unity等）进行处理。这样做的好处是可以减少代码的耦合性和提高代码的可测试性和可维护性。

>  DI指的是依赖注入，是IOC的一种实现方式。依赖注入就是在创建对象的过程中，将对象所依赖的其他对象注入到该对象中，而不是在对象内部创建这些依赖关系。这种方式可以使得代码更加灵活，便于维护和扩展。

### IOC

IOC就是控制反转;本质上就是为了解耦,通过独立接口;

把原来的组件(分离的)连接起来;对象之间的依赖关系由IOC管理

![image-20230413084304468](E:\notes\Notes\C#\assets\image-20230413084304468.png)

中间的就是IOC容器管理;

==这就是控制反转,实际上,是`获取的对象的过程被反转了`==,也就是获取依赖对象的过程由自身管理变成了IOC容器的主动注入;这个就是`依赖注入`

### 依赖注入(DI)

比如USB接口,主机无需要知道插入USB到底是什么,需要使用什么设备,只需要把设备插进去进行;

这个过程,`我`就是IOC容器;

==DI也就是依赖注入本质上是IOC的一种实现方式==

### IOC的好处

- **低耦合**

从上面的例子可以知道,IOC可以解耦,整个工程中某个组件出现问题,并不会影响另一个组件;

- **标准性**

不同的组件作者,只需要遵循接口,不需要了解另一个组件怎么写

- **可重复性**

## IOC和DI的使用

首先需要引入`using Microsoft.Extensions.DependencyInjection`

但是这个不属于.net标准库,需要使用`nuget`工具进行下载;

就可以下载第三方库

下面是使用方法

```c#
//创建IOC类
ServiceCollection services=new ServiceCollection();

//向Ioc添加服务,注意,按照接口,类的泛型进行添加
services.AddScoped<IOrder, Order>();
services.AddScoped<Ical, double_evelen>();
 //services.Add有三种模式
//singleton //单例模式  永远只构造一次
//scoped //作用域 作用域内
//tansient 瞬时模式 调用几次GetService机会创建几次
IServiceProvider serviceProvider=services.BuildServiceProvider();
var order=serviceProvider.GetService<IOrder>();

```

因为IOC依赖类的接口,所以既要有类,也要有接口;

接着Build,返回IService的接口,调用GetService,用泛型,返回IOrder接口;

这个时候直接调用IOrder的接口就行,整个过程,即类和接口绑定的过程,完全被c#封装了;

也就是原来的

```C#
Ical d_evelen = new double_evelen();
Ical normal = new normal();
if(DateTime.Now.Month==11 && DateTime.Now.Day == 11)
            {
                var o = new Order(d_evelen);
                o.Total = 10;
            }
            else
            {
                var o = new Order(normal);
                o.Total = 10;
                o.ship();
            }
```

因为原来的类有一个`Has-a`的接口关系,使用依赖注入,完全是由依赖注入库给你封装好了;

但是要使用依赖注入,即IOC,必须像前面USB接口那样,每个类都出个接口;而且类里面必须有个

`has-a`接口的关系,本质上IOC就是用了==面向接口编程==;

==事实上,前面的接口就体现了依赖注入的思想==即前面的双十一计算器,他不传入类,和类没有`Has-a`的关系,

而是传入接口,实现接口的多态;这样就可以使类之间降低耦合性；

## NuGet项目依赖管理

这个是C#的最关键的东西,都是项目构建和依赖解析的;

![image-20230413095720998](E:\notes\Notes\C#\assets\image-20230413095720998.png)

通过依赖项就是可以看到依赖,

- 包

就是第三方库,类似Dll

- Project

源代码级别的引用

- 框架

dotnet本身的依赖

以上所有的依赖管理,都是NuGet管理的;

# Chap07 C#高级编程

## 结构体

```C#
访问修饰符 struct name{
    
    
    
}
```

就是cpp的struct,结构体是属于值类型的,在栈中存储;

## 枚举

```C#
enmu WeekDay{
    monday,
    tuesday,
    ....
}
```

`monday==0`,后面以此类推;值得一提的是,WeekDay在C#用Console.WriteLine会默认ToString;

也就是会打印字符串;

## 泛型

### 泛型的使用

C#也有泛型,`var list=new List<xx>();`

事实上,C#因为万物皆是`Object`类的派生类;可以用Object来进行泛型，但是会频繁装箱拆箱;所以效率较低;;

C#使用泛型,只需要这样

```c#
public class GPList<T>{
    
    
}
```

总的来说,和CPP不同的是,CPP想要使用`GP`

需要现在前面声明`template <Typename xx>`,而C#则是`public class name<T>{}`,函数同样是这样;

### 泛型的特化

和Cpp的特化差不多

```c++
public class XX<T>where T:Order{
    
    
}
```

这样就可以使用`XX`就只能处理Order和其派生对象了;

事实上,这样有点像CPP的函数的范围特化,只不过`C#`的这个封装更上一层楼;甚至可以使用`类`或者`接口`的函数;

这一点是非常非常重要的;

### 函数的泛型

```c#
public T FindMax<T>(T x,T y){
    
    return a>b? a:b;
}
```

但是这样会报错,因为泛型的T不一定可以比较;

这个时候可以使用C#内建接口`IComparable`来进行修改

```c#
public T FindMax<T>(T x,T y) where T : IComparable{
    
    return a.CompareTo(b)>0? a:b;
}
```

使用这个参数就可以确定T一定可以比较,其次使用a.CompareTo这个`Object`的函数;

这个where T :后面的可以是类,可以是接口;

事实上,这个接口只有一个函数,那就是` int CompareTo(object? obj);`

别忘了,接口一旦`继承`,那么在类中必须实现这个函数;

所以a.CompareTo()就是继承这个接口要实现的;

可以理解为`where T:class or interface`就是对T的一种修饰;

事实上,`Where T : x`可以包含下面四种

![image-20230413112316255](E:\notes\Notes\C#\assets\image-20230413112316255.png)

最后的那个new()可以理解为一个接口,这个结构必须包含默认的`ctor`;

## 空处理nullable

在C#,值类型都是在栈的,所以值要么是预定义要么是默认的值;

但是无法给值对象复制`null`;

`bool isNull=null;`这样是错误的;

但是可能有特殊的情况

![image-20230413113639799](E:\notes\Notes\C#\assets\image-20230413113639799.png)

```c++
public class Nullable<T> where T : struct 
    {
        private object _vaule;
        public Nullable() { 
        
            
        }

        public Nullable(T vaule) { 
        
            _vaule = vaule;

        }

        public bool HasVaule
        {
            get
            {
                return _vaule != null;
            }

        }

        public T GetVauleOrDefault()
        {
            if(HasVaule)
            {
                return (T)_vaule;

            }
            else
            {
                return default(T);
            }

        }
    }
```

事实上,C#自带了Nullable;

```c#
Nullable<DateTime> data= null;
DateTime? data = null;
```

使用C#自带的Nullable可以这样写

第一种就是Nullable的正常写法,利用泛型,而第二种是C#的语法糖;

接着,测试下述代码

```c#
DateTime? data = null;
Console.WriteLine(data.GetValueOrDefault());
Console.WriteLine(data.HasValue);
Console.WriteLine(data.Value);
```

![image-20230413114125943](E:\notes\Notes\C#\assets\image-20230413114125943.png)

不难发现,一旦调用data.Vaule会出错,因为这个时候是Null;无法访问;

如果想要装箱拆箱的话,需要用下面的代码

![image-20230413114836290](E:\notes\Notes\C#\assets\image-20230413114836290.png)

如果是Nullable<T>到vaule的转换,推荐使用GetVauleOrDeafult;

反过来则可以之间转换,因为默认构造函数;

### 拓展方法-静态类

运行我们通过拓展方法向C#的类添加代码;

这是因为C#的标准库大部分都是`Sealed`,不可以被继承的;

```c#
 public  static class StringExtension
    {

        public static string ShortTerm(this string s,int number)
        {

            return s.Substring(0, number);
        }
    }
```

所有的类和成员方法都必须是`static`

这样就可以在类中使用这个新定义的函数了

```c#
var s = new String("SSSSS");
Console.WriteLine(s.ShortTerm(5));
```

## Dynamic 类型

即分为静态类型语言和动态类型语言;

C#是属于略偏静态类型语言;属于强语言；

```c#
dynamic excle = new Excle("tabtab");
excle.ShowTable();
```

`dynamic`是动态确定类型,他和`var`有本质区别;

所以`excle.`的时候,在编译区间并不会提示一些东西;

## 反射

C#中是通过反射,不使用`new`,不知道对象类型,也可以进行操作的过程;

### 元数据 Metadata

> meta+A=关于A的A

![image-20230413142715168](E:\notes\Notes\C#\assets\image-20230413142715168.png)

在编程中,查看或者使用程序的元数据就叫做`反射`;

### 反射的使用

```c#

string classLocation = "HelloWorld.List,C#高级编程";
//使用反射 获取元数据
Type objType = Type.GetType(classLocation);
object obj=Activator.CreateInstance(objType);
MethodInfo add= objType.GetMethod("Add");
add.Invoke(obj,null);
```

其中,classLocation的第一个就是`namespace.classname`,第二个参数是项目名称;

然后使用Type.GetType来获取Type类的元数据;

最后,使用Activator.CreateInstance(objType)来创建一个`Object`对象,事实上,这就是一个`List`,只不过不依赖于这个类型;

最后,仍然是使用元数据找到Add的名字,来进行调用;

事实上,获取元数据不一定用这个`Type.GetType()`,也可以使用`obj.GetType()`来进行获取这个Type;

==这样不难看到,其实这样反射写可以避免使用类的类型==,达到进一步降低耦合的目的;

## 反射的Dll

反射还是需要接口,使用反射的好处是可以直接通过反射来获取对应的接口,然后直接不用`New`,因为反射

直接使用`(IUSB)Activator.CreateInstance(type);`来把他强行转化成一个接口;

记得要获取Type!

那么如何确认这个Type就是你所需要的呢?

只需要来获取接口名字,这样只需要比较这个Type的接口名字有没有所需要的接口即可

```c#
var interaceList=type.GetInterfaces();
        //var mem=type.GetMembers();
        //获取InterfaceList 注意 这是从C#写的DLL获取的,可以理解为源文件
        foreach(var i in interaceList){
            
            if(i.Name == "IUSB")
            {
                //创建IUSB接口
                IUSB device=(IUSB)Activator.CreateInstance(type);
                deviceList.Add(device);
            }

        }
```

## C#异常处理

OOP,毫无疑问,C#的异常处理也是try catch 

```c#
try{
    
}catch(Exception ex){
    
    //
}

```

通过ex这个类就可以看到异常的不同属性了;

事实上,这个Exception是所有其他异常的基类;

C#同样的,也可以使用finally;

# Chap08 委托与事件

## Delegation

与CPP的委托概念是一样的,也就是自己不实现,

在C#中,委托实际上是一个类

`public delegate void DelegateFunc();`来进行声明委托;

C#中,委托实际上就是一个`指针`

然后直接使用委托这个类,但是不需要`new`

DelegateFunc d=XX类.函数();这样就可以声明一个委托函数了;

而在类中,涉及到某个函数处理的时候,并并不直接使用类本身的函数进行处理

==因为没办法扩展==,而是这样写来进行委托处理

```c#
public class XX{
    
    public processThings(class a,DelegateFunc func){
        
        func(a);
    }
    
}
```

这样在调用这个类的函数只需要

`XX.processThings(a,d);`即可实现委托;

而且在C#中,甚至可以把委托函数进行`+=`运算

![image-20230413165545987](E:\notes\Notes\C#\assets\image-20230413165545987.png)

## 预定义的委托类型

`System.Func`和`System.Action`来进行委托;两者的区别就是Func有返回值

而Action没有返回值

使用这个,就不需要在预定义委托类型的类的;

## 事件

一般来说,C#的一个类包括

- 成员属性(相当于成员变量,但是C#似乎不讲这个,而是讲属性,讲set,get)
- 成员方法
- 成员事件

这三者分别代表**数据操作和通知**,比如使用C#自带的Timer类,

![image-20230413170604062](E:\notes\Notes\C#\assets\image-20230413170604062.png)

有个Elapsed就是一个事件;

C#想要使用成员事件,就必须先绑定事件的委托;

`alarm.Elapsed+=handler.AlarmHandler`;

既然是委托函数,所以这个函数格式就固定,为如下

**值得注意的是,应该每一个类的事件的委托函数都不太一样**,比如Timer这个类就是预定义的

```c#
public void AlarmHandler(Object sender,ElasedEventArgs e);
```

事实上,第二个参数还可以用`EventArgs`来表示;这是所有事件委托函数的第二个参数

### 委托式自定义事件

事件也是属于类的成员的一种,因此要声明在类中,但是一定要是`public`的,类似接口;

而且需要`event`这个关键词

而事件需要重写两个关键字,这一点很像C#的成员属性的get,set;

```c#
private 委托 _orderEvent;
public event 委托 name{
    
    add{
        
        this._orderEvent+=value;
        
    }
    remove{
        
        this._orderEvent--value;
    }
}
```

然后,需要在类中==需要发送事件的函数==继续判断,是不是委托函数已经被委托过了;

先创建委托函数所需要的

```c#
public void Process(Order order){
    
    if(_orderEvent!=null){
        //事件的委托不是0
        var e=new ElasedEventArgs(x,x,x);
        
    }
    //调用委托函数
    _orderEvent(order,e);
}
```

### 字段式声明事件

这个时候只需要直接使用

`public event 委托 event`;即可不用重写add remove;

这个时候,只需要直接判断事件是不是为空就行了,而不需要判断委托函数;

也不需要在类中设置个委托成员;

==事实上==,每次没必要每次都声明的事件的委托,因为事件的委托可以知道

这个委托只有两个参数,一个是object,一个是参数列表

所以这个时候只需要使用一个模板,把Args的类传进去即可

`public event EventHandler<MyArgs> event`;

# Chap9 WPF基础

事实上,C#的WPF界面是`xaml`语言,而且VisualStdio已经封装好了;

`xaml`就是Web前端的语言的变种;

`xaml`的整体框架是被这样包含的;

```xaml
<Window x:Class="WpfApp1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp1"
        mc:Ignorable="d"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <TextBox HorizontalAlignment="Left" Height="64" Margin="400,153,0,0" TextWrapping="Wrap" Text="xiaowang" VerticalAlignment="Top" Width="129"/>

    </Grid>
</Window>

```

就是`Windows`的窗口下面嵌套一个`Grid`的网格机构,然后`Grid`的网格结构后面嵌套其他空间;

`windows`是xmal的根元素,`xmlns`就是命名空间,要指定UI空间的来源;

比如`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`

windows grid button都是来自这个空间;

而xmlns:x这种命名空间,实际上它指定了当前页面所对应的页面名称;

:local也就是当前是的命名空间;

mc:Ignorable="d"就是可以忽略的控件;比如我们使用`d:Button`来忽略

```xaml
        <d:Button  Width="45" Content="haha">
            <Button.Height>
                50
            </Button.Height>
        </d:Button>
```

运行起来的时候,就可以看到区别了;也就是运行时忽略;

## 与xaml所关联的cs文件

![image-20230416100638843](E:\notes\Notes\C#\assets\image-20230416100638843.png)

打开这个就可以找到和线段xaml文件对应的后端cs数据

```C#
namespace WpfApp1
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }
    }
}
```

## UI空间的第三种方式

可以不用拖拽以及xaml来进行绘制UI;

而是通过this.Content(这个实际上)就是`Grid`,获取之后通过下述代码进行添加

```c#
public MainWindow()
        {
            InitializeComponent();
            var grid = (Grid)this.Content;
            Button button = new Button();
            button.Height = 50;
            button.Width = 50;
            this.Margin = new Thickness(0, 0, 700, 350);
            button.Content = "hha";
            grid.Children.Add(button);
        }
```

Margin就是窗口的地址;

## MVC

MVC是一种程序架构

- V代表View

也就是用户交互界面,只展示数据

- M代表Model

MVC的核心,数据处理

- C代表控制器

不处理数据,接受用户输出,调用模型完成用户请求;

### MVC结构如何运作

![image-20230416102010824](E:\notes\Notes\C#\assets\image-20230416102010824.png)

事实上最难理解的就是Model,它不仅仅是用来访问数据库的;

如果要MCV架构,C不要是核心逻辑,而是M；

## StackPanel

```xaml
    <StackPanel>
        <TextBlock HorizontalAlignment="Center" Margin="20" Text="haha"></TextBlock>
        <ListBox Height="100" Width="100">
            <ListBoxItem Content="item1"></ListBoxItem>
            <ListBoxItem Content="item2"></ListBoxItem>
            <ListBoxItem Content="item3"></ListBoxItem>
        </ListBox>
    </StackPanel>
```

目前没看出来和grid有啥区别,他似乎就是一个可以把控件一次排列

C#中,这样可以在cs文件自动生成Button_click;

  ```xaml
  <Button Click="Button_click">What
          </Button>
  ```

```c#
   private void Button_Click(object sender, RoutedEventArgs e)
        {
			MessageBox.show("haha");
        }
```

这个方法就会在我们点击的时候会被调用;事实上,这个按钮就是在逻辑树上的上的;

同样,在调试过程中,找到变量sender,就可以点击查看来找到视觉树;

![image-20230416105303557](E:\notes\Notes\C#\assets\image-20230416105303557.png)

可以看到就像一棵树一样,可以看到这就是视觉树

而逻辑树类似视觉树的子集,比如Button,ListBox等等;

## Grid

和StackPanel一样,也是用于GUI空间定位的,他是网格结构;

是有行和列的;

```XAML
   <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*"></ColumnDefinition>
            <ColumnDefinition Width="*"></ColumnDefinition>
            <ColumnDefinition Width="*"></ColumnDefinition>
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="*">
            </RowDefinition>
            <RowDefinition Height="*">
            </RowDefinition>
            <RowDefinition Height="*">
            </RowDefinition>
        </Grid.RowDefinitions>
        <Button Grid.Column="0" Grid.Row="0">click me
        </Button>
        <Button Grid.Column="1" Grid.Row="0">click me
        </Button>
        <Button Grid.Column="0" Grid.Row="1">click me
        </Button>
        <Button Grid.Column="1" Grid.Row="1">click me
        </Button>
        <TextBlock Grid.Row="2" Grid.Column="0">ahhaha</TextBlock>
    </Grid>
```



如上述代码,其中`Grid.ColumnDefinitions`以及`Grid.RowDefinitions`就是行列,因为Grid是网格;其中列只能设置宽度,

而行只能设置高度;这很容易理解;

而`xx="*"`代表权重的意思,上面都是1,说明最后效果是这样的;

![image-20230416110915234](E:\notes\Notes\C#\assets\image-20230416110915234.png)

## WrapPanel

就是`StackPanel`的另一个版本,只是他是默认水平排列的;

值得一提的是,`WrapPanel`是水平但是会换行;但是`StackPanel`不会自动换行;

事实上,所有的`StackPanel`还有`WarpPanel`都是改默认增长方向;

## DockPanel

这是停靠的界面;也就是Visiual Stdio的那种编辑框停靠,就可以通过这个实现;

## UniformGrid

他比Grid定义行列的时候更快;

直接使用

```xaml
<UniformGrid Columns="3" Rows="3"></UniformGrid>
```

此外,所有的容器都可以嵌套,比如Grid嵌套Grid;

## wpf控件样式

其实就是style,这是因为所有控件都继承同一个类;

在xmal中使用style按照如下方法

```XAML
<Window.Resources>
        <Style x:Key="ButtonStyle" TargetType="Button">
            <Setter Property="FontSize" Value="18"/>
            <Setter Property="Background" Value="AliceBlue"/>
            <Setter Property="Content" Value="HAHA"/>
        </Style>
    </Window.Resources>
    <Grid>
        <Button Style="{StaticResource ButtonStyle}">
        </Button>
```

记得加上这个样式的名字,不然就会默认全局使用;

## 控件模板

WPF有默认的外观,事实上是微软默认的; 比如下面就是一个Button默认的;

而控件模板就是用来修改普通控件的外观的;

WPF的控件只要是继承ContentControl的;都是通过COntenPresenter来呈现内容的；

```xaml
<ControlTemplate x:Key="ButtonTemplate1" TargetType="{x:Type ButtonBase}">
            <Border x:Name="border" Background="{TemplateBinding Background}" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}" SnapsToDevicePixels="true">
                <ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
            </Border>
            <ControlTemplate.Triggers>
                <Trigger Property="Button.IsDefaulted" Value="true">
                    <Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
                </Trigger>
                <Trigger Property="IsMouseOver" Value="true">
                    <Setter Property="Background" TargetName="border" Value="{StaticResource Button.MouseOver.Background}"/>
                    <Setter Property="BorderBrush" TargetName="border" Value="{StaticResource Button.MouseOver.Border}"/>
                </Trigger>
                <Trigger Property="IsPressed" Value="true">
                    <Setter Property="Background" TargetName="border" Value="{StaticResource Button.Pressed.Background}"/>
                    <Setter Property="BorderBrush" TargetName="border" Value="{StaticResource Button.Pressed.Border}"/>
                </Trigger>
                <Trigger Property="IsEnabled" Value="false">
                    <Setter Property="Background" TargetName="border" Value="{StaticResource Button.Disabled.Background}"/>
                    <Setter Property="BorderBrush" TargetName="border" Value="{StaticResource Button.Disabled.Border}"/>
                    <Setter Property="TextElement.Foreground" TargetName="contentPresenter" Value="{StaticResource Button.Disabled.Foreground}"/>
                </Trigger>
            </ControlTemplate.Triggers>
        </ControlTemplate>
```

上面的意思就是,比如我的`Margin`属性就是和Padding绑定了,你一旦删了,就没办法用Margin了;

比如上面,可以看到Background也和`Background`绑定了,==通过定义这个可以自定义控件的外观;==

## 数据模板

### 后端的添加

比如我可以通过定义一个ListBox来弄一个List控件

一般我可能会这样初始化数据

```XAML
   <ListBox Name="list">
                
            </ListBox>
```

下面这个语法可能有点难理解,但是其实也不是很难

new XX(){x=x}是C#初始化临时的局部类的一种方法

下面这几行代码的作用就是list.Items.add(ListBoxItem),而ListBoxItem为了显示数据,必须在Content中写数据;

说白了就是C#把XAML封装了一下;

```c#
      for(int i=0;i<10 ;i++)
            {
                list.Items.Add(
                    new ListBoxItem()
                    {
                        Content = new TextBlock()
                        {
                            Text = i.ToString()
                        }

                    });
                
                
            }
```

但是这是UI层面和后端相结合的,因此耦合太大;

可以使用前端的方法进行写

### 前端写法

首先,我们可以这样写,如果是纯前端的话;

```xaml
<StackPanel>
            <ListBox Name="list">
                <ListBoxItem>
                    <StackPanel Orientation="Horizontal">
                        <Border Width="10" Height="10" Background="Red">
                        </Border>
                        <TextBlock Text="Red"></TextBlock>
                    </StackPanel>
                </ListBoxItem>
            </ListBox>

        </StackPanel>
```

这样就相当于把`<ListItemBox>`里面的内容给自定义下;

![image-20230416163156075](E:\notes\Notes\C#\assets\image-20230416163156075.png)

**其实我们可以发现,对于ListBoxItem而言,他们的构造是相同的,唯一不同的是,`数据`还有`颜色`;**

**我们可以使用`数据模板`的方法,让ListBox的数据版本定义相同;**

一旦绑定之后,我们只需要关系ListBox的数据,而不是关系在`new ListBoxItem`出来

这样可以达到前后端耦合性降低;而且更方便;

这就是数据绑定的意义,==数据驱动,而不是写后端代码的时候穿插着UI==

```XAML
<ListBox Name="list">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <StackPanel Orientation="Horizontal">
                            <Border Width="10" Height="10" Background="Red">
                            </Border>
                            <TextBlock Text="Red"></TextBlock>
                        </StackPanel>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
```

`List.ItemTemplate`就是ListBox的一个属性(类),而`DataTemplate`也是一个类,这样在里面就可以定义ItemBox的ItemTemplate了;但是只是数据模板;==事实上,你把这个完全当作类就行,因为这个代码完全可以C#写==

```c#
 listbox.ItemTemplate = new DataTemplate()
            {

            };
```

而表现在`xaml`代码中就是这样了。这就是所谓的绑定数据模板;

这样,我们继续改后端的代码;只需要添加类即可;这个类无所谓,任何一个类都行;

![image-20230416163926987](E:\notes\Notes\C#\assets\image-20230416163926987.png)

可以发现,随便一个类填进去,都是可以填上新的Item的;但是问题是,没办法改item的名字;

这个时候就需要用到数据绑定来绑定数据了;

```XAML
<ListBox Name="list">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <StackPanel Orientation="Horizontal">
                            <Border Width="10" Height="10" Background="{Binding color}">
                            </Border>
                            <TextBlock Text="{Binding name}"></TextBlock>
                        </StackPanel>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
```

可以看到,添加了`Text="{Binding name}"`和`Background="{Binding color}"`

那么怎么用呢?这个时候非常简单,只需要你自己有个类,类里面有这两个属性,就可以使用数据绑定了;

![image-20230416164629471](E:\notes\Notes\C#\assets\image-20230416164629471.png)



如图,完美实现前后端解耦;太巧妙了!

### DataGrid的数据模板绑定

DataGrid就类似ListControl,它可以这样绑定

```XAML
<DataGrid>
<DataGrid.Columns>
                    <DataGridTextColumn Binding="{Binding color}" Header="color"/>
                    <DataGridTextColumn Binding="{Binding name}" Header="name"/>
</DataGrid.Columns>
</DataGrid>
```

这样,直接插入类,有这两个属性就行

同样的,上面的绑定只是简单的Text绑定,还可以绑定更多

```XAML
<DataGrid Name="list">
                <DataGrid.Columns>
                    <DataGridTextColumn Binding="{Binding color}" Header="color"/>
                    <DataGridTextColumn Binding="{Binding name}" Header="name"/>
                    

                    <DataGridTemplateColumn Header="operator">
                        <DataGridTemplateColumn.CellTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <Border Width="10" Height="10" Background="{Binding color}"/>
                                    <TextBlock Margin="10" Text="{Binding name}"/>
                                </StackPanel>
                            </DataTemplate>
                        </DataGridTemplateColumn.CellTemplate>
                    </DataGridTemplateColumn>
                </DataGrid.Columns>
                
            </DataGrid>
```

上面,把Column最后一列自定义了；甚至还可以自定义按钮;

![image-20230416171210830](E:\notes\Notes\C#\assets\image-20230416171210830.png)

## WPF的绑定

### 控件和事件的绑定

比如我想实现一个Slider控件和TextBox控件两个有一个变动,另一个也变动,那么可以通过事件绑定控件来进行;

那么在`xaml`文件中需要这样写

```XAML
<StackPanel>
            <Slider x:Name="slider" Margin="5" ValueChanged="slider_ValueChanged"/>
            <TextBox x:Name="textbox1" TextChanged="textbox1_TextChanged"/>
        </StackPanel>
```

其中ValueChanged和TextChanged就是控件绑定事件;

而在前端需要这样写

```C#
       private void slider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            textbox1.Text=slider.Value.ToString();

        }

        private void textbox1_TextChanged(object sender, TextChangedEventArgs e)
        {
            double result;
            double.TryParse(textbox1.Text,out result);
            slider.Value = result;
        }
```

### 控件和控件的绑定

上面的控件和事件绑定,可以发现,其实只是想单纯的让两个控件联系起来而已;没必要写后端;

来进行双向绑定;

事实上,控件绑定控件的语法是

`xx="{Binding ElementName=name Path=x Mode=x} "`

其中name就是绑定的控件名称,而path就是绑定控件的哪个属性,而Mode就是绑定的模式;

比如TowWay就是双向绑定;

![image-20230416173308696](E:\notes\Notes\C#\assets\image-20230416173308696.png)

### 控件和类属性(变量)的绑定

同样,也是相同的绑定方法,只不过绑定的类型不一样,绑定类属性直接

`xx={Binding 类属性}`,即可;

但是这个类属性到哪里去找呢?这个时候就需要绑定`this.DataContext`了,

可以把他理解为控件的数据上下文,这是个类,绑定的属性去这里面实现即可;

```C#
      public MainWindow()
        {
            InitializeComponent();
            this.DataContext = new Context_Data() { data="haha"};

        }

        public class Context_Data
        {
            public string data { get; set; }

        }
```

## WPF命令

事实上,一般按钮并不会使用业务代码,也就是按钮的事件进行驱动;

而是为了降低耦合度,通过命令绑定的形式;

```XAML
<Button Command="{Binding showCommand}">
        </Button>
```

绑定的这个showCommnad必须是一个`类`,而且必须继承了`ICommand`接口;

```C#
public class  MyCommand :ICommand
    {
        private Action _Action;
        public MyCommand(Action action) { _Action = action; }

        public event EventHandler CanExecuteChanged;

        bool ICommand.CanExecute(object? parameter)
        {
            return true;
        }

        void ICommand.Execute(object? parameter)
        {
            _Action();
        }
    }
```

这个类最好再写一个`委托`,这是因为为了`解耦`,通过外界传入;然后业务代码这样写

```C#
 public class MainViewModel
    {
        public MainViewModel() { 
        
            showCommand=new MyCommand(show);
        }
        public MyCommand showCommand { get; set; }
        public void show()
        {

            MessageBox.Show("CLICK BUTTON");
        }
    }
```

直接把业务代码传给这个类的`委托`函数;

最后,因为这本质上还是一个类属性的绑定,所以别忘了绑定上下文

```C#
 public MainWindow()
        {
            InitializeComponent();
            this.DataContext = new MainViewModel();

        }
```

### INotifyPropertyChanged

 现在考虑下面这种情况,即想要通过点击按钮,来使按钮的Text发生改变;

这样毫无疑问用到了控件绑定属性，但是会出现问题,即哪怕你的绑定的变量变化了,控件的属性还没有及时变化,这个时候就需要`INotifyPropertyChanged`这个接口了;

事实上,这个接口里面只有一个委托函数;

这个委托函数是这样定义的

```C#
public interface INotifyPropertyChanged
    {
        //
        // 摘要:
        //     Occurs when a property value changes.
        event PropertyChangedEventHandler? PropertyChanged;
    }
```

也就是要在类中实现委托

```c#
private string name;

        public event PropertyChangedEventHandler? PropertyChanged;

        public string Name
        {
            get
            {
                return name;
            }
            set { name = value;
                //委托?.Invoke是防御性编程
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Name"));
            }

        }
```

这样,把之前绑定的换成`Name`,一旦修改Name,就会调用Set,调用Set就会调用委托函数;

委托函数的第一个sender毫无疑问就是`this`,而第二个就是哪一个值变化了,直接填就行,这样即可实现属性变化通知控件;==前提是类属性必须绑定控件的属性,而且这个类必须继承INotifyPropertyChanged==这个接口,来实现接口里面的委托;

# Chap10 C#和数据库

数据库的基础语法是

`select *(全部) 表项 from 表名`

## C#链接使用数据库

C#想要使用现场的数据库,需要装一个NuGet下个包,叫做`System.Data.SqlClient`;

```c#
string connectString = "Data Source=localhost\\SQLEXPRESS;Initial Catalog=master;Integrated Security=True";

            //c#链接数据库
            _sqlConnection=new SqlConnection(connectString);
```

上面就是链接数据库,而SqlConnection可以理解位数据库的实例;

如果想要使用数据库的语法,需要使用

`SqlDataAdapter sqlDataAdapter = new SqlDataAdapter("select * from Customers", _sqlConnection);`来返回一个数据库适配器,即`sqlDataAdapter`

然后使用

```C#
DataTable customerTable=new DataTable();
sqlDataAdapter.Fill(customerTable);
```

即可填充DataTable;可以把DataTable理解成`数据,而且有行列`

如果想要把获取的`DataTable`用于xaml的ListBox,需要这样

```C#
using (sqlDataAdapter)
            {
                DataTable customerTable=new DataTable();
                sqlDataAdapter.Fill(customerTable);
                CustomersList.ItemsSource = customerTable.DefaultView;
                CustomersList.DisplayMemberPath = "Name";
                CustomersList.SelectedValuePath = "ID";
            }
```

这里是用了控件的属性绑定,属性源自于`customerTable.DefaultView;`,

这里不用设置`DataContext`是因为我已经绑定ListBox的数据源了;

一般来说

不是每个控件都有 `ItemsSource` 属性。 `ItemsSource` 属性是特定类型的控件（例如 `ListBox`、`ComboBox` 和 `DataGrid`）用于绑定数据源的属性。这些控件允许您将一组数据与一个或多个 UI 元素关联起来，以便在界面上显示数据。

其他控件（例如 `Button`、`TextBox`、`Label` 等）没有 `ItemsSource` 属性，因为它们通常用于显示单个值或文本，而不是数据集合。

总的来说， `ItemsSource` 属性是一种特定于某些控件的属性，用于绑定数据源。其他控件可能有不同的属性用于不同的用途，但不一定都是 `ItemsSource`。

### 数据库关联的使用

这里用到了数据库的关联,因为客户有张数据表,而客户应当还有一张与之关联的预约时间表;

这里需要再把数据库创建一张信标,然后创建新表关联外键,关联Customers表的Id外键;

```SQL
CONSTRAINT [FK_Appointments_Customers] FOREIGN KEY (CustomersId) REFERENCES Customers(Id) 
```

这个时候,使用如下进行查询

```SQL
select * from Appointments join Customers on 
Appointments.CustomersId=Customers.Id where Customers.Id=2
```

![image-20230417105258215](E:\notes\Notes\C#\assets\image-20230417105258215.png)

可以发现查询了如下的数据;这个语法就是查询表然后关联外键的查询方式,要记住;

这个时候在C#中,其实就改变了个sql requry语句而已;

```c#
int CustomersId = (int)CustomersList.SelectedValue;
            string query = "select * from Appointments join Customers on " +
                $"Appointments.CustomersId=Customers.Id where Customers.Id={CustomersId}";
            SqlDataAdapter sqlDataAdapter = new SqlDataAdapter(query,_sqlConnection);
            //执行SQL 语句获取数据库
            //数据库查询是通过select 字段 from 数据表来查询的

            //C#垃圾回收机制
            using (sqlDataAdapter)
            {
                DataTable appointTable = new DataTable();
                sqlDataAdapter.Fill(appointTable);
                appointList.ItemsSource = appointTable.DefaultView;
                appointList.DisplayMemberPath = "Time";
                //CustomersList.ClipToBounds = true;
                appointList.SelectedValuePath = "Id";
            }
```

这样,设计了数据源,即可;

### C#的数据库删除

数据库删除用到了`delete from Appointments where CustomersId=5`这个指令

对于委托的删除很简单,但是对于人员的删除不太简单,因为另一张表还和这个有关联,这个时候需要先删除关联的主键项,再删人员;

此外,C#的删除用到了另一个类,叫做`SqlCommand()`,使用起来很简单

```C#
SqlCommand cmd1 = new SqlCommand(sqlDeleteAppointment, _sqlConnection);
_sqlConnection.Open();
cmd1.ExecuteScalar();
_sqlConnection.Close();
```

记得一定要`_sqlConnection.Close()`来进行数据库链接的关闭;这里最好放在Finally中;

### SQL 添加数据

很简单,只需要`insert into Customers values ('SSS','SSS','SSS')`;

但是,因为类型是nchar,所以在C#应该这样写

```C#
string query = $"insert into Customers values('{name}','{id}','{address}')";
```

### SQL 修改数据

SQL 修改数据需要使用`update tablename set xx='xx',xx='xx' where Id=x`这种形式来进行修改;

# Chap11 wpf美化

## 数据模型

数据模型就是一种可以描述复杂事务的方法,比如`建模`这个概念;

